---
id: 212
title: '6502 &#8211; !etÄ›vs ,johA'
date: 2014-02-28T15:30:32+00:00
author: Martin Maly
layout: post
guid: http://strojak.uelectronics.info/?p=212
permalink: /6502-etevs-joha/
dsq_thread_id:
  - "2335592322"
categories:
  - "6502"
---
VÅ¡echno jde udÄ›lat i jinak, hlavnÄ› v osmibitovÃ©m assembleru. TakÅ¾e ani pro Hello, world nenÃ­ jen jedinÃ½ pÅ™edepsanÃ½ postup.

<!--more-->

V [prvnÃ­ ukÃ¡zce](http://strojak.uelectronics.info/6502-ahoj-svete/ "6502 â€“ Ahoj, svÄ›teâ€¦") jsem pouÅ¾il postup, kterÃ©mu se Å™Ã­kÃ¡ ASCIIZ &#8211; tedy ASCII Å™etÄ›zec, ukonÄenÃ½ bajtem Â s hodnotou 0 (ASCII + Zero). Tento zpÅ¯sob zÃ¡pisu Å™etÄ›zcÅ¯ pouÅ¾Ã­vajÃ­ tÅ™eba pÅ™ekladaÄe jazyka C &#8211; kdo z vÃ¡s znÃ¡ CÃ©Äko, tak vÃ­.

Jazyk Pascal pouÅ¾Ã­val jinÃ½ pÅ™Ã­stup &#8211; prvnÃ­ bajt udÃ¡val dÃ©lku Å™etÄ›zce ve znacÃ­ch, a pak nÃ¡sledovaly kÃ½Å¾enÃ© znaky. NÄ›kdy mÅ¯Å¾e bÃ½t tento pÅ™Ã­stup vÃ½hodnÄ›jÅ¡Ã­ &#8211; hlavnÄ› tehdy, kdyÅ¾ nÃ¡m dÃ©lku spoÄÃ­tÃ¡ pÅ™ekladaÄ a natvrdo uloÅ¾Ã­ do kÃ³du. Jak by se to pÅ™epsalo do assembleru 6502?

Tak, zÃ¡klad zÅ¯stane stejnÃ½ &#8211; definice konstant, inicializace i rutina SEROUT, jen ten vnitÅ™ek se zmÄ›nÃ­. Registr X pouÅ¾ijeme jako poÄÃ­tadlo a index znaku v Å™etÄ›zci. KdyÅ¾ dosÃ¡hne hodnoty rovnÃ© dÃ©lce Å™etÄ›zce, pÅ™estaneme. Ta zÃ¡sadnÃ­ pasÃ¡Å¾ kÃ³du bude vypadat nÄ›jak takhle:

<pre class="lang:asm decode:true">; ZaÄÃ­nÃ¡me vypisovat znaky 
TOUT:     LDX     #0 ; pozice
TLOOP:    LDA     text,x 
          JSR     SEROUT
          INX     ; X++
          CPX	  #tsize ; uÅ¾ jsme na konci?
          BNE     tloop ; pokud ne (tj. X&lt;dÃ©lka), tak pokraÄujeme

ENDLOOP:          
          JMP     endloop 

TEXT:     DB      $0C,"My hovercraft is full of eels!",$0D,$0A
TSIZE     EQU     $-TEXT</pre>

## A co Woz?

Logout mÄ› [upozornil](http://blog.i-logout.cz/vsechno-je-jednou-poprve.php), Å¾e Steve Wozniak v monitoru pro Apple I pouÅ¾il trik, kterÃ½m uÅ¡etÅ™il nÄ›kolik bajtÅ¯ (a tedy taktÅ¯ procesoru). AÄkoli mi jeho trik pÅ™ipadÃ¡ v tomto pÅ™Ã­padÄ› jako klasickÃ½ pÅ™Ã­klad &#8222;overengineeringu&#8220; (tedy optimalizace aÅ¾ pÅ™ehnanÃ¡), tak si ji ukÃ¡Å¾eme, protoÅ¾e ilustruje schopnost podÃ­vat se na problÃ©m z naprosto neobvyklÃ©ho Ãºhlu. CoÅ¾ se zase pÅ™i programovÃ¡nÃ­ v assembleru Äasto hodÃ­.

ÃšvodnÃ­ Ãºvaha je jednoduchÃ¡: na zaÄÃ¡tku se nuluje registr X, v prÅ¯bÄ›hu se pak zvyÅ¡uje o 1 a kontroluje se, jestli uÅ¾ mÃ¡ hodnotu N. Kdybychom na zaÄÃ¡tku do registru X uloÅ¾ili hodnotu N a Å¡li v opaÄnÃ©m poÅ™adÃ­, tedy smÄ›rem k nule, tak by odpadla instrukce porovnÃ¡nÃ­ a konec by nastal ve chvÃ­li, kdy instrukce DEX (X=X-1) dojde k nule. Pak nastavÃ­ pÅ™Ã­znak Z (viz [popis instrukce](http://strojak.uelectronics.info/instrukce-6502-aritmetika/ "Instrukce 6502 â€“ aritmetika")).

Nese to s sebou jeden drobnÃ½ problÃ©m: ÄtenÃ­ znakÅ¯ by fungovalo od konce. Hm, a co? Tak je tam zapÃ­Å¡eme pozpÃ¡tku!

<pre class="lang:asm decode:true">; ZaÄÃ­nÃ¡me vypisovat znaky 
TOUT:     LDX     #tsize ; X je poÄet znakÅ¯, co zbÃ½vÃ½ vypsat
TLOOP:    LDA     text-1,x 
                  ; A protoÅ¾e X jde od hodnoty TSIZE k nule,
                  ; tak se znaky berou od konce
          JSR     SEROUT
          DEX     ; X-- 
          BNE     tloop ; a dokud nenÃ­ 0, tak pokraÄujeme

ENDLOOP:          
          JMP     endloop 

TEXT:     DB      $0a,$0d,"slee fo lluf si tfarcrevoh yM",$0c
TSIZE     EQU     $-TEXT</pre>

UÅ¡etÅ™ili jsme dva bajty a nÄ›jakÃ½ ten takt, pÅ™iÅ¡li jsme o snadnou Äitelnost. Ano, pÅ™i programovÃ¡nÃ­ osmibitÅ¯ jsou situace, kdy dva bajty Äi pÃ¡r taktÅ¯ znamenÃ¡ hodnÄ›. (Spousta programÃ¡torÅ¯, co na assemblerech vyrostla, pak logicky povaÅ¾uje cokoli jinÃ©ho za plÃ½tvÃ¡nÃ­ ad absurdum.)

## JeÅ¡tÄ› nÄ›jakÃ½ trik, prosÃ­m!

_&#8222;Ale no jistÄ›,_&#8220; odpovÄ›dÄ›lo sluchÃ¡tko. PojÄte se podÃ­vat na nÃ¡sledujÃ­cÃ­ kÃ³d:



PÅ™eloÅ¾te si ho, spusÅ¥te emulÃ¡tor a pojÄme krokovat:

<pre class="lang:asm decode:true">0000                  .ORG 0 
0000 A2 FF            LDX #$FF 
0002 9A               TXS 
0003 20 09 00         JSR label 
0006 4C 00 00         JMP 0 
0009 60        LABEL:   RTS</pre>

PrvnÃ­ instrukce (adresa 0000, 2 bajty) nastavÃ­ X na hodnotu FFh, druhÃ¡ (adresa 0002, 1 bajt)Â tuto hodnotu zkopÃ­ruje do ukazatele zÃ¡sobnÃ­ku S. TÅ™etÃ­ instrukce (adresa 0003, 3 bajty) je [instrukce volÃ¡nÃ­ podprogramu](http://strojak.uelectronics.info/instrukce-6502-skoky-a-podprogramy/ "Instrukce 6502 â€“ skoky a podprogramy"). VolÃ¡ se podprogram na adrese 0009&#8230;

V tuto chvÃ­li se zastavÃ­me a podÃ­vÃ¡me se na vrchol zÃ¡sobnÃ­ku, co se tam uloÅ¾ilo. VÃ­me, Å¾e instrukce JSR uklÃ¡dÃ¡ dva bajty nÃ¡vratovÃ© adresy. ProtoÅ¾e byl ukazatel nastaven na FFh, budou tyto dva bajty na adresÃ¡ch 01FEh a 01FFh. Co tam najdeme?

Na zÃ¡sobnÃ­ku je uloÅ¾ena hodnota 0005. VidÃ­me, Å¾e to nenÃ­ adresa instrukce za volÃ¡nÃ­m JSR (ta je 0006), ale o 1 niÅ¾Å¡Ã­. Instrukce RTS vezme hodnotu ze zÃ¡sobnÃ­ku, k nÃ­ pÅ™iÄte 1 a na tu adresu skoÄÃ­.

K Äemu nÃ¡m bylo tohle mentÃ¡lnÃ­ cviÄenÃ­? UkÃ¡Å¾eme si totiÅ¾ jeden princip, kterÃ½ se u osmibitovÃ½ch assemblerÅ¯ pouÅ¾Ã­vÃ¡ docela Äasto, a nejÄastÄ›ji prÃ¡vÄ› u vÃ½pisu rÅ¯znÃ½ch textÅ¯. Pokud se text vyskytuje v programu jen jednou a je konstantnÃ­ (tj. typicky nÄ›jakÃ© hlÃ¡Å¡enÃ­), tak je pro programÃ¡tora pohodlnÃ© napsat ho pÅ™Ã­mo do kÃ³du, tam, kde potÅ™ebuje. UÅ¡etÅ™Ã­ tÃ­m sekvenci &#8222;zadej nÄ›kam adresu hlÃ¡Å¡enÃ­, co chceÅ¡ vypsat &#8211; zavolej rutinu, kterÃ¡ vypÃ­Å¡e Å™etÄ›zec ze zadanÃ© adresy&#8220;. MÃ­sto toho jen zavolÃ¡ podprogram, jehoÅ¾ funkce se dÃ¡ popsat slovy &#8222;vypiÅ¡ znaky, co se nachÃ¡zejÃ­ za instrukcÃ­ JSR, a aÅ¾ narazÃ­Å¡ na ukonÄovacÃ­ znak 00, tak se vraÅ¥ za tu nulu, tam pokraÄuje program.&#8220;

NÄ›jak takhle (stÃ¡le upravujeme kÃ³d z pÅ™edchozÃ­ho pÅ™Ã­kladu):

<pre class="lang:asm decode:true">JSR     PRIMM 
          DB      $0C,"My hovercraft is full of eels!",$0D,$0A,$00 

DONE:     JMP     DONE ; TO JE KONEC!!! ğŸ™</pre>

VidÃ­te, Å¾e je tam instrukce volÃ¡nÃ­ podprogramu PRIMM (PRint IMMediately), za nÃ­ jsou pÅ™Ã­mo znaky poÅ¾adovanÃ© hlÃ¡Å¡ky, ukonÄenÃ© nulou, a za tÃ­m zase pokraÄuje program.

Co musÃ­ udÄ›lat podprogram PRIMM? PÅ™edstavte si, Å¾e je vyvolÃ¡n. V tu chvÃ­li je na zÃ¡sobnÃ­ku &#8222;adresa instrukce za JSR &#8211; 1&#8220;. Ukazatel SP je jeden bajt POD touto hodnotou, nÃ¡vratovÃ¡ adresa je tedy na adresÃ¡ch SP+1 a SP+2.

NejdÅ™Ã­v si uloÅ¾Ã­me pracovnÃ­ registry A, X a Y &#8211; tÃ­m se SP snÃ­Å¾Ã­ o 3 a situace na zÃ¡sobnÃ­ku bude vypadat takto:

<table>
  <tr>
    <td>
      SP+5
    </td>
    
    <td>
      VyÅ¡Å¡Ã­ bajt nÃ¡vratovÃ© adresy
    </td>
  </tr>
  
  <tr>
    <td>
      SP+4
    </td>
    
    <td>
      NiÅ¾Å¡Ã­ bajt nÃ¡vratovÃ© adresy
    </td>
  </tr>
  
  <tr>
    <td>
      SP+3
    </td>
    
    <td>
      Obsah registru A
    </td>
  </tr>
  
  <tr>
    <td>
      SP+2
    </td>
    
    <td>
      Obsah registru X
    </td>
  </tr>
  
  <tr>
    <td>
      SP+1
    </td>
    
    <td>
      Obsah registru Y
    </td>
  </tr>
  
  <tr>
    <td>
      SP
    </td>
    
    <td>
      PrvnÃ­ volnÃ¡ pozice na zÃ¡sobnÃ­ku
    </td>
  </tr>
</table>

TakÅ¾e na adrese SP + 0100h + 4 je niÅ¾Å¡Ã­ bajt nÃ¡vratovÃ© adresy, na adrese SP + 0100h + 5 je vyÅ¡Å¡Ã­. Tuto hodnotu si mÅ¯Å¾eme nÄ›kam zkopÃ­rovat &#8211; ideÃ¡lnÄ› do zero page do dvou bunÄ›k vedle sebe. VÃ½hodnÄ› pak vyuÅ¾ijeme [adresnÃ­ mÃ³d IZY](http://strojak.uelectronics.info/adresni-mody-6502/ "AdresnÃ­ mÃ³dy 6502"). PÅ™ipomeÅˆme si: tento mÃ³d vezme adresu ze dvou vedle sebe leÅ¾Ã­cÃ­ch pamÄ›Å¥ovÃ½ch mÃ­st, k tÃ© adrese pÅ™iÄte obsah registru Y a vÃ½sledek udÃ¡vÃ¡ adresu, kam se mÃ¡ sahat pro data.

Jakmile narazÃ­me na konec Å™etÄ›zce (anebo nÃ¡m pÅ™eteÄe registr Y), tak konÄÃ­me s vypisovÃ¡nÃ­m. TeÄ je potÅ™eba vzÃ­t tu pÅ¯vodnÃ­ adresu, k nÃ­ pÅ™iÄÃ­st poÄet vypsanÃ½ch znakÅ¯ (tedy registr Y), tu pak zase zapsat na zÃ¡sobnÃ­k &#8211; a pak uÅ¾ jen standardnÄ› vrÃ¡tit obsah registrÅ¯ a provÃ©st RTS.

A protoÅ¾e vlastnÃ­ studium zdrojovÃ©ho kÃ³du Å™ekne vÃ­c, neÅ¾ sÃ¡hodlouhÃ© popisy, tak bez dalÅ¡Ã­ho vysvÄ›tlovÃ¡nÃ­ &#8211; podprogram PRIMM:

<pre class="lang:asm decode:true">PRIMM:            
          PHA     ; UloÅ¾Ã­m A
          TXA
          PHA     ; UloÅ¾Ã­m X
          TYA
          PHA     ; UloÅ¾Ã­m Y
          TSX     ; Ukazatel na zÃ¡sobnÃ­k si naÄtu do X
          LDA     $0104,X ; NiÅ¾Å¡Ã­ byte nÃ¡vratovÃ© adresy 
          		  ; ($0100 je zÃ¡kladnÃ­ adresa zÃ¡sobnÃ­ku, X je tu aktuÃ¡lnÃ­
                  ; ukazatel zÃ¡sobnÃ­ku, +4 proto, Å¾e ukazatel SP ukazuje na
                  ; prvnÃ­ volnÃ© mÃ­sto, SP+1 je uloÅ¾enÃ½ registr X,
                  ; SP+2 je uloÅ¾enÃ½ registr Y, SP+3 je uloÅ¾enÃ½ registr A
                  ; (na zaÄÃ¡tku podprogramu jsme si je uklÃ¡dali)
                  ; SP+4 a SP+5 jsou niÅ¾Å¡Ã­ a vyÅ¡Å¡Ã­ bajt nÃ¡vratovÃ© adresy,
                  ; tedy poslednÃ­ bajt instrukce JSR

          STA     $00 ; UloÅ¾Ã­me do ZP (tÅ™eba na adresu 00)
          LDA     $0105,X ; Analogicky vyÅ¡Å¡Ã­ byte nÃ¡vratovÃ© adresy...
          STA     $01 ; ... uklÃ¡dÃ¡me do ZP na adresu 01
          LDY     #$01 ; NastavÃ­me Y na poÄÃ¡teÄnÃ­ hodnotu. MÄ›la by to bÃ½t
          		  ; nula, ale protoÅ¾e vÃ­me, Å¾e nÃ¡vratovÃ¡ adresa je ve 
                  ; skuteÄnosti o 1 niÅ¾Å¡Ã­, neÅ¾ adresa prvnÃ­ho bajtu za JSR,
                  ; tak zaÄneme od jedniÄky.
PRIM2:            
          LDA     ($00),Y ; NaÄteme bajt. Adresa je "obsah bunÄ›k 00 a 01" + Y
          BEQ     PRIM3 ; NaÄetli jsme nulu? Tak konÄÃ­me!

          JSR     SEROUT ; NenulovÃ½ znak ale vypÃ­Å¡eme
          INY     ; posuneme se na dalÅ¡Ã­ adresu
          BNE     PRIM2 ; a pokud jsme jeÅ¡tÄ› nepÅ™etoÄili poÄÃ­tadlo, tak 
                  ; pokraÄujeme v tisknutÃ­ znakÅ¯.
                  ; KdyÅ¾ uÅ¾ je Y nulovÃ©, tak je naÄase skonÄit.

PRIM3:            
          TYA     ; V Y je "poÄet znakÅ¯ + 1" - pÅ™esuneme do A
          CLC     ; budeme sÄÃ­tat, je potÅ™eba vynulovat C
          ADC     $00 ; K A si pÅ™iÄteme niÅ¾Å¡Ã­ bajt pÅ¯vodnÃ­ nÃ¡vratovÃ© adresy
          STA     $0104,X ; a "podvrhneme" ji do zÃ¡sobnÃ­ku
          LDA     #$00 ; Vynulujeme A
          ADC     $01 ; a pÅ™iÄteme hodnotu vyÅ¡Å¡Ã­ho byte nÃ¡vratovÃ© adresy.
          	      ; Pokud pÅ™i pÅ™edchozÃ­m sÄÃ­tÃ¡nÃ­ doÅ¡lo k pÅ™enosu, tak se 
                  ; vyÅ¡Å¡Ã­ bajt zvedne o 1, jinak zÅ¯stane stejnÃ½
          STA     $0105,X ; A opÄ›t vyÅ¡Å¡Ã­ bajt nÃ¡vratovÃ© hodnoty analogicky 
                  ; uloÅ¾Ã­me na zÃ¡sobnÃ­k a budeme se tvÃ¡Å™it, Å¾e to tak
                  ; uÅ¾ bylo
          PLA     ; PÅ™eÄteme uloÅ¾enou hodnotu
          TAY     ; co patÅ™Ã­ do registru Y
          PLA     ; a ÃºplnÄ› stejnÄ› tu, co
          TAX     ; patÅ™Ã­ do registru X
          PLA     ; jeÅ¡tÄ› pÅ¯vodnÃ­ hodnotu A
          RTS     ; a nÃ¡vrat!</pre>

MÅ¯Å¾ete si zkusit sloÅ¾it celÃ½ zdrojovÃ½ kÃ³d a vyzkouÅ¡et, jak hezky funguje. (Nebo si mÅ¯Å¾ete kliknout [sem](http://www.asm80.com/index.html#demo/strojak2.a65) a on se vÃ¡m automaticky pÅ™idÃ¡ do pracovnÃ­ho prostoru v ASM80 IDE).

(Rutina PRIMM pochÃ¡zÃ­ z operaÄnÃ­ho systÃ©mu Commodore C64 a je mÃ­rnÄ› upravena, viz [zdroj](http://www.6502.org/source/io/primm.htm).)

_Pro pozornÃ©: v kÃ³du <del>je jedna chyba, kterÃ¡</del>Â jsou dvÄ› chyby, kterÃ© se projevÃ­ pÅ™i urÄitÃ© konstelaci &#8211; zkuste na nÄ› pÅ™ijÃ­t._

Mimochodem &#8211; existuje jeÅ¡tÄ› jeden pouÅ¾Ã­vanÃ½ zpÅ¯sob oznaÄovÃ¡nÃ­ konce Å™etÄ›zcÅ¯, hlavnÄ› u anglickÃ½ch textÅ¯. KromÄ› zadanÃ©ho poÄtu znakÅ¯ + Å™etÄ›zce nebo Å™etÄ›zce ukonÄenÃ©ho bajtem 00h (u CP/M sluÅ¾ba pro vypisovÃ¡nÃ­ Å™etÄ›zcÅ¯ pouÅ¾Ã­vÃ¡ ukonÄovÃ¡nÃ­ znakem $) mÅ¯Å¾eme pouÅ¾Ã­t i trik, kterÃ½ poÄÃ­tÃ¡ s tÃ­m, Å¾e anglickÃ¡ abeceda si v ASCII vystaÄÃ­ se znaky z rozsahu 00h-7Fh. Pak staÄÃ­ poslednÃ­mu znaku nastavit nejvyÅ¡Å¡Ã­ bit na 1 (tj. posunout jej do rozsahu 80h-FFh). Ze znaku &#8222;!&#8220; (kÃ³d 21h) se tak stane znak s kÃ³dem A1h. No a postup je prostÃ½ &#8211; pÅ™ed vypsÃ¡nÃ­m znaku pouÅ¾ijeme AND s hodnotou 7Fh (abychom nastavili nejvyÅ¡Å¡Ã­ bit na 0), znak vypÃ­Å¡eme a pak zkontrolujeme, jestli nenÃ­ nejvyÅ¡Å¡Ã­ bit roven 1 (u 6502 tÅ™eba tak, Å¾e ho naÄteme do registru A &#8211; tÃ­m se nejvyÅ¡Å¡Ã­ bit zkopÃ­ruje do pÅ™Ã­znaku N). Pokud ano, byl to poslednÃ­ znak a my se mÅ¯Å¾eme vrÃ¡tit. NapsÃ¡nÃ­ rutiny, kterÃ¡ bude takto pracovat, nechÃ¡m uÅ¾ na vÃ¡s, mÃ¡te to za domÃ¡cÃ­ Ãºkol&#8230;