---
id: 203
title: '6502 &#8211; Ahoj, svÄ›te&#8230;'
date: 2014-02-21T16:28:26+00:00
author: Martin Maly
layout: post
guid: http://strojak.uelectronics.info/?p=203
permalink: /6502-ahoj-svete/
dsq_thread_id:
  - "2298866638"
categories:
  - "6502"
---
Nastala chvÃ­le, kdy kÅ™emÃ­k oÅ¾ije a provede, co po nÄ›m chceme. Tedy aspoÅˆ ten virtuÃ¡lnÃ­&#8230;

<!--more-->

U 8080 to bylo prostÃ© &#8211; [nabÃ­dnul jsem PMD-85](http://strojak.uelectronics.info/8080-ahoj-svete/ "8080 â€“ Ahoj svÄ›te!"), k nÄ›mu mÃ¡m i emulÃ¡tor, takÅ¾e nebyl problÃ©m. U 6502 by Å¡lo vyuÅ¾Ã­t tÅ™eba Atari nebo Commodore C64, problÃ©m je, Å¾e k nim emulÃ¡tor nemÃ¡m. Zato mÃ¡m emulÃ¡tor jednodeskovÃ©ho poÄÃ­taÄe [SBC6502](http://searle.hostei.com/grant/6502/Simple6502.html) od Granta Searla. Jeho poÄÃ­taÄ je extrÃ©mnÄ› jednoduchÃ½, tvoÅ™Ã­ ho, vÄetnÄ› procesoru, sedm integrovanÃ½ch obvodÅ¯ a mÅ¯Å¾ete si ho posklÃ¡dat na nepÃ¡jivÃ©m kontaktnÃ­m poli, kdyÅ¾ na to pÅ™ijde.

GrantÅ¯v poÄÃ­taÄ obsahuje procesor 6502, u nÄ›ho je generÃ¡tor hodin, logika pro dekÃ³dovÃ¡nÃ­ adres a sÃ©riovÃ½ komunikaÄnÃ­ obvod ACIA 6850. Od adresy 0000h do adresy 7FFFh je 32 kB RAM. ROM mÃ¡ 16 kB a je na adresÃ¡ch C000h aÅ¾ FFFFh. V prostoru A000h &#8211; BFFFh je namapovÃ¡n sÃ©riovÃ½ komunikaÄnÃ­ obvod, k nÄ›muÅ¾ se jeÅ¡tÄ› dostanu.

Grant do svÃ©ho poÄÃ­taÄe pouÅ¾il Microsoft BASIC 6502 (od adresy C000h) a k nÄ›mu pÅ™idal rutiny pro komunikaci pÅ™es sÃ©riovÃ½ port. PoÄÃ­taÄ je tak moÅ¾nÃ© pÅ™ipojit k sÃ©riovÃ©mu portu u PC (tÅ™eba i pomocÃ­ pÅ™evodnÃ­ku RS232-USB) a komunikovat s nÃ­m pomocÃ­ terminÃ¡lu (Hyperterminal, PuTTY atd.) JÃ¡ jsem do emulÃ¡toru napsal i emulaci terminÃ¡lu, takÅ¾e nemusÃ­te nic s niÄÃ­m spojovat a vÅ¡echno funguje v prohlÃ­Å¾eÄi. MÅ¯Å¾ete si vyzkouÅ¡et [emulÃ¡tor SBC6502 se zabudovanÃ½m BASICem](http://www.asm80.com/sbc6502.html).

Ale co kdyÅ¾ nebude BASIC? Jak oÅ¾ivit takovÃ½ holÃ½ poÄÃ­taÄ? ZaÄneme vÃ½pisem obligÃ¡tnÃ­ho HELLO WORLD. K tomu ale budeme muset nÄ›jak ovlÃ¡dat ten komunikaÄnÃ­ obvod&#8230; NaÅ¡tÄ›stÃ­ to nenÃ­ sloÅ¾itÃ©, a tak si aspoÅˆ ukÃ¡Å¾eme, jak v takovÃ½ch chvÃ­lÃ­ch postupovat.

Co mÃ¡me? MÃ¡me typ obvodu &#8211; 6850. ACIA je zkratka (Asynchronous Communications Interface Adapter), kterÃ¡ Å™Ã­kÃ¡, Å¾e se jednÃ¡ o komunikaÄnÃ­ rozhranÃ­. VÃ½robce je Motorola (a dalÅ¡Ã­), obvod je z rodiny podpÅ¯rnÃ½ch obvodÅ¯ procesoru 6800. Chvilku poGooglÃ­me a najdeme takzvanÃ½ [datasheet](http://www.classiccmp.org/dunfield/r/6850.pdf). Datasheet je materiÃ¡l, dodÃ¡vanÃ½ vÃ½robcem Äipu, kde jsou popsÃ¡ny veÅ¡kerÃ© dÅ¯leÅ¾itÃ© skuteÄnosti &#8211; od napÃ¡jecÃ­ho napÄ›tÃ­ pÅ™es popis vÃ½vodÅ¯ a pouzdra aÅ¾ k programÃ¡torskÃ©mu rozhranÃ­. naÅ¡tÄ›stÃ­ ho nemusÃ­te ÄÃ­st, pÅ™eÄetl jsem ho za vÃ¡s, a tady jsou shrnuty zÃ¡kladnÃ­ informace &#8211; vynechÃ¡m to, co je pro nÃ¡s nepodstatnÃ© (Å™Ã­zenÃ­ spojenÃ­ pomocÃ­ signÃ¡lÅ¯ RTS, CTS apod. nebo pÅ™eruÅ¡enÃ­)

## ACIA 6850

Obvod 6850 je sÃ©riovÃ½ komunikaÄnÃ­ obvod. ([Datasheet](http://www.classiccmp.org/dunfield/r/6850.pdf), [programÃ¡torskÃ½ popis](http://www.electronics.dit.ie/staff/tscarff/6800/6850acia/6850.htm)) Je pÅ™ipojen k procesoru a jeho hlavnÃ­m Ãºkolem je pÅ™evÃ©st zaslanÃ½ bajt na sÃ©riovÃ½ signÃ¡l standardu RS-232 (tj. sprÃ¡vnÄ› odvysÃ­lat start bit, datovÃ© bity, pÅ™Ã­padnÄ› paritnÃ­ bit, a nakonec stop bit) a opaÄnÄ›, tj. naÄÃ­st sprÃ¡vnÄ› ÄasovanÃ½ sÃ©riovÃ½ signÃ¡l a pÅ™ipravit ho k pÅ™edÃ¡nÃ­ procesoru.

AsynchronnÃ­ v popisu znamenÃ¡, Å¾e spolu s daty nenÃ­ pÅ™enÃ¡Å¡en hodinovÃ½ signÃ¡l ani nenÃ­ Äinnost pÅ™esnÄ› ÄasovÃ¡na &#8211; kdyÅ¾ pÅ™ijde bajt, je vyslÃ¡n, kdyÅ¾ pÅ™ijdou vstupnÃ­ sÃ©riovÃ¡ data, jsou naÄtena. Synchronizace, tj. to, Å¾e bude naÄteno opravdu to, co naÄteno bÃ½t mÃ¡, zajiÅ¡Å¥ujÃ­ prÃ¡vÄ› start a stop bity &#8211; podle jejich sprÃ¡vnÃ©ho prÅ¯bÄ›hu poznÃ¡ obvod, Å¾e jsou data v poÅ™Ã¡dku.

VysÃ­lÃ¡nÃ­ dat po vÃ½stupu TXDATA (Tx = transmit) a pÅ™Ã­jem na vstupu RXDATA (Rx = receive) je ÄasovÃ¡n pomocÃ­ systÃ©movÃ½ch hodin. U Grantova poÄÃ­taÄe je systÃ©movÃ½ kmitoÄet roven 1,8432 MHz. Tento kmitoÄet je v ACIA vnitÅ™nÄ› dÄ›len, dÄ›litel je programovÄ› nastavitelnÃ½. Grant pouÅ¾Ã­vÃ¡ dÄ›lenÃ­ Å¡estnÃ¡cti, coÅ¾ znamenÃ¡, Å¾e komunikaÄnÃ­ rychlost je 1843200 / 16 = 115200 bitÅ¯ za sekundu (baud). Pokud jste nÄ›kdy pouÅ¾Ã­vali sÃ©riovÃ© rozhranÃ­, vÃ­te, Å¾e 115200 je jedna z pouÅ¾Ã­vanÃ½ch komunikaÄnÃ­ch rychlostÃ­.

Obvod 6850 s procesorem komunikuje pomocÃ­ osmibitovÃ© datovÃ© sbÄ›rnice (D0-D7), nÄ›kolika CS vstupÅ¯ (CS = Chip Select), kterÃ© urÄujÃ­, kdy se s obvodem komunikuje (CS0 = 1, CS1 = 1, CS2 = 0 &#8211; ve vÅ¡ech ostatnÃ­ch pÅ™Ã­padech je datovÃ¡ sbÄ›rnice odpojena), vstupu E (Enable, obvod komunikuje jen pokud je E=1), vstupu R/W, kterÃ½ udÃ¡vÃ¡, zda se z obvodu Äte (1) nebo se do nÄ›j zapisuje (0) a vstupu RS, kterÃ½ udÃ¡vÃ¡, jestli se Ätou/zapisujÃ­ data (1), nebo Å™Ã­dicÃ­ hodnoty (0).

PÅ™Ã­stup k obvodu mÃ¡ pak urÄitÃ¡ pravidla toho, jak majÃ­ a mohou po sobÄ› jednotlivÃ© signÃ¡ly nÃ¡sledovat, za jak dlouho po pÅ™ivedenÃ­ signÃ¡lu jsou pÅ™ipravenÃ¡ data apod. Z hlediska programÃ¡tora jsou tyto informace vÄ›tÅ¡inou (ne vÅ¾dy!) irelevantnÃ­, protoÅ¾e o ÄasovÃ¡nÃ­ signÃ¡lÅ¯ se starÃ¡ vnÄ›jÅ¡Ã­ logika.Â _NÄ›kdy se ale nepostarÃ¡, a pak je potÅ™eba, aby napÅ™. programÃ¡tor mezi poslÃ¡nÃ­m dvou hodnot nÄ›jakou chvÃ­li poÄkal, ale to nÃ¡vrhÃ¡Å™ systÃ©mu vÄ›tÅ¡inou zmÃ­nÃ­._

Z hlediska programÃ¡tora se tedy obvod 6502 jevÃ­ jako dva registry (vybranÃ© pomocÃ­ vstupu RS), z nichÅ¾ jeden je datovÃ½, druhÃ½ &#8222;systÃ©movÃ½&#8220;. Funkci osvÄ›tlÃ­ tabulka:

<table>
  <tr>
    <th colspan="2">
      Vstupy
    </th>
    
    <th colspan="2">
      Registry
    </th>
  </tr>
  
  <tr>
    <th>
      RS
    </th>
    
    <th>
      R/W
    </th>
    
    <th>
      Typ registru
    </th>
    
    <th>
      Funkce
    </th>
  </tr>
  
  <tr>
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
      ZÃ¡pis
    </td>
    
    <td>
      Å˜Ã­dicÃ­ registr (Control Register, CR)
    </td>
  </tr>
  
  <tr>
    <td>
    </td>
    
    <td>
      1
    </td>
    
    <td>
      ÄŒtenÃ­
    </td>
    
    <td>
      StavovÃ½ registr (Status Register, SR)
    </td>
  </tr>
  
  <tr>
    <td>
      1
    </td>
    
    <td>
    </td>
    
    <td>
      ZÃ¡pis
    </td>
    
    <td>
      Data k vyslÃ¡nÃ­ (Transmit Data Register, TDR)
    </td>
  </tr>
  
  <tr>
    <td>
      1
    </td>
    
    <td>
      1
    </td>
    
    <td>
      ÄŒtenÃ­
    </td>
    
    <td>
      PÅ™ijatÃ¡ data (Receive Data Register, RDR)
    </td>
  </tr>
</table>

Grant Searle svÅ¯j poÄÃ­taÄ zapojil tak, Å¾e na adrese A000h je Å™Ã­dicÃ­ / stavovÃ½ registr (CR/SR, podle toho, jestli se Äte nebo zapisuje), na adrese A001h jsou datovÃ© registry. Vzhledem k tomu, Å¾e pouÅ¾il jen jednoduchÃ½ dekodÃ©r, tak se CR/SR objevuje i na adresÃ¡ch A002h, A004h, &#8230; aÅ¾ do BFFEh, datovÃ½ pak na adresÃ¡ch o 1 vyÅ¡Å¡Ã­ (A001h, A003h, &#8230; BFFFh). PodobnÃ© &#8222;nedokonalÃ©&#8220; dekÃ³dovÃ¡nÃ­ je pomÄ›rnÄ› ÄastÃ© &#8211; Å¡etÅ™Ã­ to totiÅ¾ &#8222;drahÃ©&#8220; souÄÃ¡stky a nezbytnou logiku.

VÅ¡imnÄ›te si, Å¾e do Å™Ã­dicÃ­ho registru je moÅ¾nÃ© pouze zapisovat, nelze z nÄ›j ÄÃ­st, naopak stavovÃ½ registr lze pouze ÄÃ­st, nelze do nÄ›j zapisovat. NenÃ­ to totiÅ¾ potÅ™eba. TotÃ©Å¾ s datovÃ½mi registry &#8211; pÅ™i ÄtenÃ­ se Äte to, co obvod pÅ™ijal (a nezajÃ­mÃ¡ nÃ¡s to, co jsme odeslali). PÅ™i zÃ¡pisu je jasnÃ©, Å¾e chceme data vyslat, nedÃ¡valo by smysl zapisovat do pÅ™ijatÃ½ch dat.

### Å˜Ã­dicÃ­ registr CR

OsmibitovÃ½ registr CR Å™Ã­dÃ­ ÄtyÅ™i funkce obvodu:

  * Bity 0 a 1 nastavujÃ­ dÄ›licÃ­ pomÄ›r hodin, viz vÃ½Å¡e.
  
    | CR1 | CR0 | DÄ›litel |
    | --- | --- | ------- |
    |     |     | 1       |
    |     | 1   | 16      |
    | 1   |     | 64      |
    | 1   | 1   | RESET   |
    
    PoslednÃ­ kombinace nenastavuje dÄ›litele, ale celÃ½ obvod resetuje do vÃ½chozÃ­ho nastavenÃ­, tj. vyprÃ¡zdnÃ­ registry a nuluje pÅ™Ã­znaky. Grant pouÅ¾Ã­vÃ¡ kombinaci 01, tj. dÄ›lenÃ­ 16. Kdyby pouÅ¾il kombinaci 10, tj. dÄ›lenÃ­ 64, komunikoval by obvod rychlostÃ­ 28800 Bd.</li> 
    
      * Bity 2, 3 a 4 nastavujÃ­ dÃ©lku vysÃ­lanÃ½ch a pÅ™ijÃ­manÃ½ch dat (sedmibitovÃ© nebo osmibitovÃ©), zda se pracuje s paritou a kolik je stop bitÅ¯. Tyto informace najdete napÅ™. i v nastavenÃ­ HyperterminÃ¡lu, kdyÅ¾ pÅ¯jdete hledat detaily pÅ™ipojenÃ­. Pro naÅ¡e ÃºÄely pouÅ¾ijeme kombinaci 101, tj. osmibitovÃ½ pÅ™enos, bez parity, 1 stop bit.
      * Bity 5 a 6 urÄujÃ­, jestli vysÃ­laÄ po odvysÃ­lanÃ©m bajtu bude Å¾Ã¡dat o pÅ™eruÅ¡enÃ­ a v jakÃ©m stavu bude vÃ½stup RTS
      * Bit 7 urÄuje, jestli pÅ™ijÃ­maÄ bude vyvolÃ¡vat pÅ™eruÅ¡enÃ­ v pÅ™Ã­padÄ› chyby.</ul> 
    
    Pro bliÅ¾Å¡Ã­ popis odkazuju zÃ¡jemce opÄ›t k datasheetu, my pouÅ¾ijeme hodnotu 15h, tj. osmibitovÃ½ pÅ™enos, bez parity, pÅ™eruÅ¡enÃ­ zakÃ¡zanÃ© a pÅ™enosovÃ¡ rychlost 115200 Baud (Baud je jednotka &#8222;bitÅ¯ za sekundu&#8220; &#8211; vÄetnÄ› start a stop bitÅ¯).
    
    ### StavovÃ½ registr SR
    
    SvÄ›t nenÃ­ dokonalÃ½, Å¾ivot nenÃ­ fÃ©r a asynchronnÃ­ sÃ©riovÃ© pÅ™enosy nejsou nijak sladÄ›nÃ© s biorytmy naÅ¡eho procesoru. Pokud poÅ¡lu bajt do 6850, zaÄne ho obvod vysÃ­lat. OvÅ¡em pÅ™edtÃ­m je dobrÃ© podÃ­vat se, jestli uÅ¾ dokonÄil vysÃ­lÃ¡nÃ­ toho pÅ™edchozÃ­ho. PÅ™i pÅ™Ã­jmu je zase dobrÃ© se podÃ­vat, jestli nÄ›jakÃ½ bajt uÅ¾ naÄetl, a pokud ho naÄetl, tak ho zpracovat, aby se uvolnilo mÃ­sto pro dalÅ¡Ã­ bajt. PopÅ™Ã­padÄ› zÃ­skat informaci o tom, jestli nedoÅ¡lo k chybÄ›. Tyhle informace jako kdyÅ¾ najdete ve stavovÃ©m registru SR.
    
    Pokud naÄtete bajt ze SR, tak vÃ¡s jednotlivÃ© bity informujÃ­ o nÃ¡sledujÃ­cÃ­m:
    
      * Bit 0 &#8211; Receiver Data Register Full (RDRF). Pokud je nastaven na 1, znamenÃ¡ to, Å¾e obvod naÄetl bajt po sÃ©riovÃ© lince do pÅ™ijÃ­maÄe a bylo by zÃ¡hodno ho zpracovat. Jakmile procesor pÅ™eÄte stav datovÃ©ho registru, je bit RDRF nastaven na 0. Nula znamenÃ¡, Å¾e Å¾Ã¡dnÃ½ novÃ½ bajt nepÅ™iÅ¡el.
      * Bit 1 &#8211; Transmitter Data Register Empty (TDRE). Jakmile zapÃ­Å¡ete do datovÃ©ho registru bajt, nastavÃ­ se TDRE na 0 a obvod zaÄne bajt vysÃ­lat po sÃ©riovÃ© lince. Jakmile ho vyÅ¡le, nastavÃ­ tento bit na 1. ProgramÃ¡tor by se mÄ›l pÅ™ed tÃ­m, neÅ¾ nÄ›jakÃ½ bajt poÅ¡le, zkontrolovat, Å¾e mÅ¯Å¾e &#8211; tedy Å¾e bit TDRE = 1.
      * Bity 2, 3 pracujÃ­ s Å™Ã­dicÃ­mi signÃ¡ly CTS, DCD, a jÃ¡ je tady s klidnÃ½m svÄ›domÃ­m opomenu.
      * Bit 4 &#8211; Framing Error (FE) znamenÃ¡, Å¾e pÅ™ijatÃ¡ data byla Å¡patnÄ› ÄasovÃ¡na, napÅ™. Å¾e nepÅ™iÅ¡el poÅ¾adovanÃ½ STOP bit.
      * Bit 5 &#8211; Receiver Overrun (OVRN). Overrun, neboli hezky ÄeskyÂ _pÅ™ebÄ›h_, je stav, kdy pÅ™ijÃ­maÄ pÅ™ijal bajt, ale procesor jeÅ¡tÄ› nezpracoval pÅ™edchozÃ­ pÅ™ijatÃ½. Ten novÄ› pÅ™ijatÃ½ je tedy zahozenÃ½ (protoÅ¾e jej nenÃ­ kam dÃ¡t, Å¾Ã¡dnÃ½ vnitÅ™nÃ­ buffer nenÃ­) a nastavÃ­ se OVRN na 1, aby bylo jasnÃ©, Å¾e doÅ¡lo k chybÄ›.
      * Bit 6 &#8211; Parity Error (PE). Pokud vyuÅ¾Ã­vÃ¡me pÅ™enos s paritou, zkontroluje 6850 paritnÃ­ bit. Pokud byl chybnÃ½, nastavÃ­ pÅ™Ã­znak PE.
      * Bit 7 &#8211; Interrupt Request (IRQ) Å™Ã­kÃ¡, Å¾e obvod poÅ¾Ã¡dal o pÅ™eruÅ¡enÃ­ z nÄ›jakÃ©ho zÃ¡vaÅ¾nÃ©ho dÅ¯vodu. BuÄ byl pÅ™ijat bajt a je povolenÃ© pÅ™eruÅ¡enÃ­ pÅ™i pÅ™ijetÃ­ dat, nebo byl odeslÃ¡n bajt a je povoleno pÅ™eruÅ¡enÃ­ pÅ™i odeslÃ¡nÃ­, nebo vypadla nosnÃ¡ (DCD).
    
    ## Jak pracovat s 6850?
    
    Na zaÄÃ¡tku musÃ­me nastavit Å™Ã­dicÃ­ registr tak, jak potÅ™ebujeme. UÅ¾ jsme si Å™ekli, Å¾e to bude hodnota 15h. TÃ­m je obvod nastaven a pÅ™ipraven k pÅ™ijÃ­mÃ¡nÃ­ a vysÃ­lÃ¡nÃ­ dat.
    
    <pre class="lang:asm decode:true">ACIA         =  $A000 
ACIACONTROL  =  ACIA+0 
ACIASTATUS   =  ACIA+0 
ACIADATA     =  ACIA+1 

    LDA     #$15    ; 115200 Bd, 8 bit, no parity, 1 stop bit, no IRQ
    STA     ACIAControl</pre>
    
    Na zaÄÃ¡tku jsou pojmenovanÃ© adresy ACIA (bÃ¡zovÃ¡ adresa obvodu 6850 v GrantovÄ› poÄÃ­taÄi), ACIAControl, ACIAStatus a ACIAData. Vyhneme se tak programÃ¡torskÃ©mu moru, &#8222;magickÃ½m konstantÃ¡m&#8220;. (Syntaxe &#8222;nÃ¡vÄ›Å¡tÃ­ = hodnota&#8220; je ekvivalentnÃ­ zÃ¡pisu &#8222;nÃ¡vÄ›Å¡tÃ­ EQU hodnota&#8220;, kterÃ½ jsme pouÅ¾Ã­vali u 8080. FunkÄnÄ› je to totÃ©Å¾, jen u asesemblerÅ¯ 8080 je zvykem zÃ¡pis s EQU, u 6502 zÃ¡pis s rovnÃ­tkem.)
    
    Do registru A uloÅ¾Ã­m poÅ¾adovanÃ© Å™Ã­dicÃ­ slovo (15h) a instrukcÃ­ STA ho zapÃ­Å¡u na adresu ACIAControl (tj. A000h). VzpomeÅˆte si, Å¾e [procesor 6502 nerozliÅ¡uje mezi pamÄ›tÃ­ a porty](http://strojak.uelectronics.info/architektura-6502/ "Architektura 6502"), obojÃ­ mÃ¡ v jednom adresnÃ­m prostoru, takÅ¾e pouÅ¾Ã­vÃ¡me normÃ¡lnÃ­ ibnstrukci pro zÃ¡pis do pamÄ›ti. VnÄ›jÅ¡Ã­ logika Grantova poÄÃ­taÄe se postarÃ¡ o to, Å¾e data neskonÄÃ­ v pamÄ›ti, ale tam, kde majÃ­, tj. v obvodu 6850.
    
    Co dÃ¡l? Obvod je nastaven, teÄ je zapotÅ™ebÃ­ vypsat ono obligÃ¡tnÃ­ HELLO WORLD. NÄ›kde v pamÄ›ti tedy bude tenhle Å™etÄ›zec a my ho budeme bajt po bajtu prochÃ¡zet a vysÃ­lat na sÃ©riovÃ½ vÃ½stup.
    
    KdyÅ¾ se Å™ekne &#8222;vysÃ­lat&#8220;, tak si na to udÄ›lÃ¡me podprogram. Bude se jmenovat tÅ™eba SEROUT (jako Å¾e SERial OUTput) a jeho funkce bude, Å¾e vyÅ¡le hodnotu v registru A. PÅ™edtÃ­m si ale zkontroluje, jestli je vysÃ­laÄ volnÃ½. MusÃ­ si tedy naÄÃ­st hodnotu stavovÃ©ho registru SR a zkontrolovat bit 1. Pokud je nulovÃ½, musÃ­ poÄkat, aÅ¾ bude 1.
    
    <pre class="lang:asm decode:true">SEROUT:   PHA     
SO_WAIT:  LDA     ACIAStatus 
          AND     #2 
          BEQ     SO_WAIT 
          PLA     
          STA     ACIAData 
          RTS</pre>
    
    Na zaÄÃ¡tku si uloÅ¾Ã­m obsah registru A. MÃ¡m v nÄ›m ten bajt, co chci vyslat, ale budu ten registr potÅ™ebovat, protoÅ¾e si do nÄ›j naÄtu hodnotu stavovÃ©ho registru. TakÅ¾e si jeho hodnotu uloÅ¾Ã­m na zÃ¡sobnÃ­k.
    
    Na dalÅ¡Ã­m Å™Ã¡dku naÄtu hodnotu stavovÃ©ho registru do registru A (LDA). Pak provedu logickÃ½ souÄin (AND) s hodnotou 2. Hodnota 2 totiÅ¾ binÃ¡rnÄ› vypadÃ¡ takto: 00000010 &#8211; jsou to tedy samÃ© nuly, jen na pozici bitu 1, kterÃ½ potÅ™ebuju testovat, je jedniÄka. VÃ½sledkem logickÃ©ho souÄinu bude buÄ hodnota 2, pokud je bit 1 nastaven, nebo 0, pokud je nulovÃ½.
    
    PÅ™ipomeÅˆme si: pokud je bit 1 stavovÃ©ho registru nulovÃ½, znamenÃ¡ to, Å¾e obvod 6850 jeÅ¡tÄ› vysÃ­lÃ¡ pÅ™edchozÃ­ data a my musÃ­me poÄkat, dokud to nedokonÄÃ­. Tedy pokud je (hodnota stavovÃ©ho registru AND 02) rovna nule, ÄekÃ¡me. A pÅ™esnÄ› to zajiÅ¡Å¥uje dalÅ¡Ã­ instrukce BEQ. [VzpomeÅˆte si](http://strojak.uelectronics.info/instrukce-6502-skoky-a-podprogramy/ "Instrukce 6502 â€“ skoky a podprogramy") &#8211; pokud je pÅ™Ã­znak Z=1 (tedy pÅ™edchozÃ­ operace skonÄila s vÃ½sledkem 0), tak BEQ skÃ¡Äe. Tady se skÃ¡Äe opÄ›t na naÄtenÃ­ stavovÃ©ho bajtu a vÅ¡e se opakuje, dokud nenÃ­ vÃ½sledek nenulovÃ½. V tu chvÃ­li uÅ¾ vÃ­me, Å¾e mÃ¡ 6850 volno a mÅ¯Å¾eme vysÃ­lat.
    
    Pokud je tedy volno, pÅ™eÄteme si ze zÃ¡sobnÃ­ku zpÄ›t hodnotu, co byla pÅ¯vodnÄ› v registru A a pomocÃ­ STA ji zapÃ­Å¡eme do datovÃ©ho registru 6850 &#8211; ACIAData.
    
    SprÃ¡vnÃ¡ otÃ¡zka je: Co se stane, kdyÅ¾ nÃ¡hodou bude obvod 6850 vadnÃ½, nebo nebude zapojenÃ½ sprÃ¡vnÄ› a bude vracet poÅ™Ã¡d hodnotu 0? V takovÃ©m pÅ™Ã­padÄ›, ano, tuÅ¡Ã­te sprÃ¡vnÄ›, jste prÃ¡vÄ› vygenerovali nekoneÄnou smyÄku, ve kterÃ© se bude procesor toÄit do skonÃ¡nÃ­ vÄ›kÅ¯ &#8211; pardon, do vypnutÃ­ napÃ¡jenÃ­, do RESETu nebo do pÅ™eruÅ¡enÃ­.
    
    ### JeÅ¡tÄ› to dÃ¡t dohromady&#8230;
    
    UÅ¾ zbÃ½vÃ¡ vlastnÄ› jen drobnost &#8211; vzÃ­t jednotlivÃ© znaky onoho slavnÃ©ho nÃ¡pisu a jeden po druhÃ©m vyslat po sÃ©riovÃ© lince ven.
    
    Znaky zapÃ­Å¡eme do pamÄ›ti pomocÃ­ pseudoinstrukce DB, kterÃ¡ uloÅ¾Ã­ hodnotu jednotlivÃ½ch znakÅ¯ jako jejich ASCII kÃ³d. Å˜etÄ›zec ukonÄÃ­me hodnotou 0. TÃ­m smyÄka poznÃ¡, Å¾e je konec a Å¾e uÅ¾ je vÅ¡echno vyslÃ¡no. K adresaci pouÅ¾ijeme indexovÃ½ registr Y. Na poÄÃ¡tku bude jeho hodnota 0 a po kaÅ¾dÃ©m znaku se hodnota zvÃ½Å¡Ã­ o 1. PomocÃ­ [adresnÃ­ho mÃ³du ABY](http://strojak.uelectronics.info/adresni-mody-6502/ "AdresnÃ­ mÃ³dy 6502") (absolutnÃ­ adresa, indexovanÃ¡ s registrem Y) budeme naÄÃ­tat do registru A postupnÄ› jednotlivÃ© znaky SlavnÃ©ho NÃ¡pisu a pak budeme volat SEROUT, aby je odeslal po sÃ©riovÃ© lince &#8211; tedy do terminÃ¡lu, kterÃ½ je zobrazÃ­.
    
    <pre class="lang:asm decode:true">LDY     #0 
LOOP:     
          LDA     Message,Y 
          BEQ     DONE
          JSR     SEROUT 
          INY     
          BNE     LOOP
DONE:     JMP DONE

Message:   
          DB      $0C,"My hovercraft is full of eels!",$0D,$0A,$00</pre>
    
    Po naÄtenÃ­ znaku je jednoduchÃ½ test: je-li naÄtenÃ½ znak roven 0, tak instrukce LDA nastavila pÅ™Ã­znak Z na jedniÄku. Instrukce BEQ v takovÃ©m pÅ™Ã­padÄ› skoÄÃ­ na nÃ¡vÄ›Å¡tÃ­ DONE. NÃ¡sleduje volÃ¡nÃ­ podprogramu (JSR), zvÃ½Å¡enÃ­ ukazatele (indexovÃ©ho registru Y) a pokud jeÅ¡tÄ› nenÃ­ 0 (coÅ¾ by znamenalo, Å¾e se vyslalo 256 bajtÅ¯ a jedeme znovu od zaÄÃ¡tku), tak se skÃ¡Äe na nÃ¡vÄ›Å¡tÃ­ LOOP, tedy na naÄtenÃ­ bajtu z adresy (Message+Y).
    
    Na nÃ¡vÄ›Å¡tÃ­ DONE je pak nekoneÄnÃ¡ smyÄka, kterÃ¡ de facto zastavÃ­ procesor. V reÃ¡lnÃ©m nasazenÃ­ to asi nebude Å¾Ã¡doucÃ­, ale pro nÃ¡s je dobrÃ©, aby procesor udÄ›lal, co udÄ›lat mÃ¡, a pak nikde netrajdal a nedÄ›lal nÄ›co, co dÄ›lat nemÃ¡.
    
    ### A to je vÅ¡echno?
    
    Ano, to je vÅ¡echno. CelÃ¡ ta nÃ¡dhera vypadÃ¡ takhle:
    
    <pre class="lang:asm decode:true">; NastavenÃ­ adres pro komunikaÄnÃ­ obvod ACIA 6850
ACIA         =  $A000 
ACIACONTROL  =  ACIA+0 
ACIASTATUS   =  ACIA+0 
ACIADATA     =  ACIA+1 

; program zaÄÃ­nÃ¡ na adrese C000h, tedy tam, kde zaÄÃ­nÃ¡ ROM
          .ORG    $C000
; EmulÃ¡tor mÃ¡ zaÄÃ­t odsud
          .ENT    $
; K testu pouÅ¾ij emulÃ¡tor poÄÃ­taÄe SBC6502 - pouze pro IDE ASM80.com
          .ENGINE sbc6502 
; VstupnÃ­ adresa
RESET:          
; NastavÃ­me si ukazatel zÃ¡sobnÃ­ku  
          LDX     #$FF 
          TXS     
; NastavenÃ­ Å™Ã­dicÃ­ho registru ACIA
          LDA     #$15
          STA     ACIAControl 

; ZaÄÃ­nÃ¡me vypisovat znaky, Y je ukazatel
          LDY     #0 
LOOP:     
          LDA     Message,Y ; NaÄti znak ze zprÃ¡vy na pozici Y
          BEQ     DONE      ; Jestli je to 0, tak hop!
          JSR     SEROUT    ; Jinak zavolej podprogram pro vyslÃ¡nÃ­ znaku
          INY               ; Y++ - abychom adresovali dalÅ¡Ã­ bajt
          BNE     LOOP      ; a jestli toho jeÅ¡tÄ› nebylo dost, tak hop na zaÄÃ¡tek
DONE:     JMP     DONE      ; TO JE KONEC!!! ğŸ™

Message:   
          DB      $0C,"My hovercraft is full of eels!",$0D,$0A,$00 

; podprogram pro vyslÃ¡nÃ­ hodnoty z registru A
; pÅ™es sÃ©riovÃ½ obvod 6850 na terminÃ¡l
SEROUT:   PHA     ; UschovÃ¡me hodnotu, protoÅ¾e registr A potÅ™ebujeme
SO_WAIT:  LDA     ACIAStatus ; Je volno?
          AND     #2         ; Bit 1 nÃ¡m to Å™ekne
          BEQ     SO_WAIT    ; NenÃ­? Tak to zkusÃ­me znovu, dokud nebude
          PLA                ; UÅ¾ je, takÅ¾e si vrÃ¡tÃ­me zpÄ›t hodnotu z registru A
          STA     ACIAData   ; a poÅ¡leme ji do 6850
          RTS                ; uÅ¾ nenÃ­ co na prÃ¡ci, tak se mÅ¯Å¾eme vrÃ¡tit

; NastavÃ­me vektory, kterÃ© 6502 potÅ™ebuje, aby vÄ›dÄ›l, kam
; mÃ¡ po resetu systÃ©mu skoÄit.
          .ORG    $FFFC 
          DW      reset 
          DW      reset</pre>
    
    KrÃ¡snÃ©, Å¾e?
    
    MoÅ¾nÃ¡ vÃ¡s zarazily dvÄ› vÄ›ci. Jednak Å¾e hexadecimÃ¡lnÃ­ ÄÃ­sla zapisuju ne jako 0C000h, ale jako $C000. Je to ekvivalentnÃ­ zÃ¡pis, ale byl jsem, po prÃ¡vu, upozornÄ›n, Å¾e zÃ¡pis s $ na zaÄÃ¡tku je &#8222;klasiÄtÄ›jÅ¡Ã­&#8220; a snÃ¡ze rozpoznatelnÃ½.
    
    DruhÃ¡ vÄ›c, co vÃ¡s mohla zarazit, jsou kÃ³dy $0c, $0d a $0a u Å™etÄ›zce k vÃ½pisu. JednÃ¡ se o Å™Ã­dicÃ­ znaky pro terminÃ¡l. 0C smaÅ¾e celou obrazovku, 0D pÅ™esune kurzor na zaÄÃ¡tek Å™Ã¡dku, 0A pÅ™esune kurzor na novÃ½ Å™Ã¡dek.
    
    Jak to otestovat? NejjednoduÅ¡Å¡Ã­ bude pouÅ¾Ã­t moje IDE [ASM80.com](http://www.asm80.com), kde je k dispozici pÅ™ekladaÄ i emulÃ¡tor. ZkopÃ­rujte si vÃ½Å¡e uvedenÃ½ zdrojovÃ½ kÃ³d do okna editoru, uloÅ¾te jej (vpravo tlaÄÃ­tko Save file as&#8230;) pod nÃ¡zvem &#8222;strojak1.a65&#8220; (pÅ™Ã­pona .a65 Å™Ã­kÃ¡ pÅ™ekladaÄi, Å¾e je pouÅ¾itÃ½ procesor 6502) a zkuste kliknout na Compile (nebo stisknout F9). Pokud je vÅ¡e OK, vypÃ­Å¡e se zprÃ¡va o ÃºspÄ›Å¡nÃ©m pÅ™ekladu a vlevo, v seznamu souborÅ¯, pÅ™ibudou dva soubory strojak1.a65.hex a strojak1.a65.lst. TÄ›ch si teÄ vÅ¡Ã­mat nemusÃ­te a vesele mÅ¯Å¾ete stisknout F10 (nebo kliknout na Emulator). DÃ­ky direktivÄ› &#8222;.engine&#8220;, kterou jsme pouÅ¾ili v kÃ³du, se nespustÃ­ debugger, na jakÃ½ jsme zvyklÃ­ z ukÃ¡zek kÃ³du, ale rovnou emulÃ¡tor poÄÃ­taÄe SBC6502, do pamÄ›ti se uloÅ¾Ã­ nÃ¡Å¡ pÅ™eloÅ¾enÃ½ kÃ³d a spustÃ­ se.
    
    (MÃ­sto kopÃ­rovÃ¡nÃ­ do editoru mÅ¯Å¾ete kliknout na tento odkaz: [PÅ™idat strojak1.a65 do workspace ASM80.com](http://www.asm80.com/index.html#demo/strojak1.a65) &#8211; tÃ­m se objevÃ­ v seznamu souborÅ¯. Pak ho mÅ¯Å¾ete jednoduÅ¡e otevÅ™Ã­t kliknutÃ­m na jeho nÃ¡zev v levÃ©m sloupci.)
    
    A pokud vÅ¡e fungovalo i u vÃ¡s na jedniÄku, bude vÃ½sledkem nÄ›co takovÃ©ho:
    
    [<img class="alignnone size-large wp-image-205" alt="sbcgo" src="http://strojak.uelectronics.info/wp-content/uploads/sites/7/2014/02/sbcgo-1024x495.png" width="960" height="464" srcset="https://strojak.cz/wp-content/uploads/sites/7/2014/02/sbcgo-1024x495.png 1024w, https://strojak.cz/wp-content/uploads/sites/7/2014/02/sbcgo-300x145.png 300w, https://strojak.cz/wp-content/uploads/sites/7/2014/02/sbcgo.png 1207w" sizes="(max-width: 960px) 100vw, 960px" />](http://strojak.uelectronics.info/wp-content/uploads/sites/7/2014/02/sbcgo.png)Tak. DÄ›kuju za pozornost u zatÃ­m snad nejdelÅ¡Ã­ho ÄlÃ¡nku, pÅ™Ã­padnÃ© dotazy a pÅ™ipomÃ­nky prosÃ­m jako vÅ¾dy do komentÃ¡Å™Å¯.
    
    &nbsp;